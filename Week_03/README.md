#### 递归

**应用场景**

1. 一个问题的解可以分解成多个子问题的解。
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。
3. 存在递归终止条件。

**递归代码编写技巧**

1. 找到如何将大问题分解成小问题的规律，基于此写出递推公式，推敲终止条件，将递推公式和终止条件翻译成代码。
2. 只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

**递归代码编写难点**

1. 警惕堆栈溢出。可以通过在代码中限制递归调用的最大深度。
2. 警惕重复计算。可以通过一个数据结构（比如散列表）来保存已经求解过的f(k)。当递归调用到f(k)时，先看下是否已经求解过了，如果是，则直接从散列表中取值返回，不要重复计算。

#### 回溯

**概念**

1. 类似枚举搜索，枚举所有解，找到满足期望的解。
2. 把问题求解过程分成多个阶段。每个阶段都会面对一个岔路口，先随意选一条路走。
3. 当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。

**实现**

递归

**和深度优先的区别**

1. 深度优先遍历的目的是遍历，本质是无序的。
2. 回溯法的目的是求解过程，本质是有序的。

**应用**

1. 深度优先搜索
2. 八皇后
3. 0-1背包问题
4. 图的颜色
5. 旅行商问题
6. 数独
7. 全排列
8. 正则表达式匹配

#### 分治

**概念**

1. 将原问题划分成N个规模较小、结构与原问题相似的子问题。
2. 递归低解决这些子问题，然后再合并其结果，就得到原问题的解。
   

**和递归的区别**

1. 分治算法是一种处理问题的思想。
2. 递归是一种编程技巧。
3. 分治算法一般比较适合用递归来实现。

**实现**

1. 分解：将原问题分解成一系列子问题。
2. 解决：递归地求解各个子问题，若子问题足够小，则直接求解。
3. 合并：将子问题的结果合并成原问题。

**应用条件**

1. 原问题与分解成的小问题具有相同的模式。
2. 原问题分解成的子问题可以独立求解，子问题之间没有相关性。
3. 具有分解终止条件。
4. 可以将子问题合并成原问题。
